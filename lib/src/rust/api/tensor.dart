// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_tensor`, `from_value_ref`, `parse_shape`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>
abstract class TensorImpl implements RustOpaqueInterface {
  /// Creates a copy of this tensor and its data on the same device it resides on.
  TensorImpl clone();

  /// Get the data type of the Tensor
  TensorElementType dtype();

  /// Frees the memory of a f32 pointer.
  static void freeF32Pointer({required ArrayPointer ptr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeF32Pointer(ptr: ptr);

  static TensorImpl fromArrayBool({
    List<int>? shape,
    required List<bool> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayBool(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayF32({
    List<int>? shape,
    required List<double> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayF32(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayF64({
    List<int>? shape,
    required List<double> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayF64(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayI16({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI16(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayI32({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI32(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayI64({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI64(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayI8({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI8(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayString({
    List<int>? shape,
    required List<String> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayString(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayU16({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU16(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayU32({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU32(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayU64({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU64(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayU8({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU8(
        shape: shape,
        data: data,
      );

  List<bool> getDataBool();

  Float32List getDataF32();

  ArrayPointer getDataF32Pointer();

  Float64List getDataF64();

  Int16List getDataI16();

  Int32List getDataI32();

  List<int> getDataI64();

  Int8List getDataI8();

  List<bool> getDataMutBool();

  Float32List getDataMutF32();

  Float64List getDataMutF64();

  Int16List getDataMutI16();

  Int32List getDataMutI32();

  List<int> getDataMutI64();

  Int8List getDataMutI8();

  Uint16List getDataMutU16();

  Uint32List getDataMutU32();

  List<int> getDataMutU64();

  Uint8List getDataMutU8();

  List<String> getDataString();

  Uint16List getDataU16();

  Uint32List getDataU32();

  List<int> getDataU64();

  Uint8List getDataU8();

  bool getIndexBool({required int index});

  double getIndexF32({required int index});

  double getIndexF64({required int index});

  int getIndexI16({required int index});

  int getIndexI32({required int index});

  int getIndexI64({required int index});

  int getIndexI8({required int index});

  String getIndexString({required int index});

  int getIndexU16({required int index});

  int getIndexU32({required int index});

  int getIndexU64({required int index});

  int getIndexU8({required int index});

  /// If this Tensor's underlying data is mutable
  bool isMutable();

  void setIndexBool({required int index, required bool value});

  void setIndexF32({required int index, required double value});

  void setIndexF64({required int index, required double value});

  void setIndexI16({required int index, required int value});

  void setIndexI32({required int index, required int value});

  void setIndexI64({required int index, required int value});

  void setIndexI8({required int index, required int value});

  void setIndexU16({required int index, required int value});

  void setIndexU32({required int index, required int value});

  void setIndexU64({required int index, required int value});

  void setIndexU8({required int index, required int value});

  /// Get the shape of the Tensor
  List<int> shape();
}

class ArrayPointer {
  final int data;
  final int length;

  const ArrayPointer({required this.data, required this.length});

  @override
  int get hashCode => data.hashCode ^ length.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ArrayPointer &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          length == other.length;
}

/// Enum mapping ONNX Runtime's supported tensor data types.
enum TensorElementType {
  /// 32-bit floating point number, equivalent to Rust's `f32`.
  float32,

  /// Unsigned 8-bit integer, equivalent to Rust's `u8`.
  uint8,

  /// Signed 8-bit integer, equivalent to Rust's `i8`.
  int8,

  /// Unsigned 16-bit integer, equivalent to Rust's `u16`.
  uint16,

  /// Signed 16-bit integer, equivalent to Rust's `i16`.
  int16,

  /// Signed 32-bit integer, equivalent to Rust's `i32`.
  int32,

  /// Signed 64-bit integer, equivalent to Rust's `i64`.
  int64,

  /// String, equivalent to Rust's `String`.
  string,

  /// Boolean, equivalent to Rust's `bool`.
  bool,

  /// 16-bit floating point number, equivalent to [`half::f16`] (with the `half` feature).
  float16,

  /// 64-bit floating point number, equivalent to Rust's `f64`. Also known as `double`.
  float64,

  /// Unsigned 32-bit integer, equivalent to Rust's `u32`.
  uint32,

  /// Unsigned 64-bit integer, equivalent to Rust's `u64`.
  uint64,

  /// Brain 16-bit floating point number, equivalent to [`half::bf16`] (with the `half` feature).
  bfloat16,
  complex64,
  complex128,

  /// 8-bit floating point number with 4 exponent bits and 3 mantissa bits, with only NaN values and no infinite
  /// values.
  float8E4M3Fn,

  /// 8-bit floating point number with 4 exponent bits and 3 mantissa bits, with only NaN values, no infinite
  /// values, and no negative zero.
  float8E4M3Fnuz,

  /// 8-bit floating point number with 5 exponent bits and 2 mantissa bits.
  float8E5M2,

  /// 8-bit floating point number with 5 exponent bits and 2 mantissa bits, with only NaN values, no infinite
  /// values, and no negative zero.
  float8E5M2Fnuz,

  /// 4-bit unsigned integer.
  uint4,

  /// 4-bit signed integer.
  int4,
  undefined,
}
